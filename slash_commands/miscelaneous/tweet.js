const hider = '||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​||||​|| _ _ _ _ _ _ ';
const { TwitterApi } = require('twitter-api-v2');
const Discord = require('discord.js');

// Credentials Auth API Twitter
const twitterClient = new TwitterApi({
    appKey: process.env.consumer_key,
    appSecret: process.env.consumer_secret,
    accessToken: process.env.access_token_key,
    accessSecret: process.env.access_token_secret,
});

module.exports = {
	name: 'tweet',
	description: 'Get a random tweet from an user.',
	args: true,
	options: [
		{
			name: 'username',
			description: 'Template',
			type: 'STRING',
			required: true,
		},
        {
			name: 'option',
			description: 'Template',
			type: 'STRING',
			required: false,
		},
	],
	run: async (client, interaction, args) => {
        const username = args[0];
        await gatherTweets(client, username, interaction);
    },
};

async function gatherTweets(client, username, interaction) {
    // Get data user (id, urlAvatar, name from user)
    const data_user = await twitterClient.v2.userByUsername(username, { 'user.fields': 'profile_image_url' });  
    id_user = data_user.data.id;
    url_avatar = data_user.data.profile_image_url.replace('_normal', '');
    name_user = data_user.data.name;

    // Get Tweet list from an user by ID
    const tweetList = await twitterClient.v2.userTimeline(id_user, {
        exclude: 'replies,retweets',
        max_results: '100',
        expansions: 'attachments.media_keys', 'tweet.fields': 'attachments', 'media.fields': 'media_key,url,height,type', 
    });
    try {
        await tweetList.fetchNext();
    } catch (error) {
        return interaction.editReply('No ha sido posible acceder a la cuenta.');
    }
    
    // Get amount of tweets from tweetList and the tweet id obtained by a random number from tweetList
    amount_tweets = Object.keys(tweetList.data.data).length;
    const randomNumber = (Math.random() * (amount_tweets - 1 + 1)) << 0;
    tweet_id = tweetList.data.data[randomNumber].id;
    // Get current tweet selected by random number and remove their URL generated by Twitter 
    content_tweet = tweetList.tweets[randomNumber].text.replace(/https?:\/\/t\.co\/\S+\s*$/g, '');

    // Get object of current tweet in order to find type media if possible
    tweet_object = tweetList.data.data[randomNumber];

    media_objects = [];
    let hq_video_url = 'none';

    try {
        // Media keys from current tweet and all data from media dict
        current_keys = tweetList.data.data[randomNumber].attachments.media_keys; 
        media_data = tweetList.data.includes.media;

        // Find data of media (key, type and url) from keys and push them to an array
        for(const item in current_keys) {
            for(const sub_item in media_data) {
                // console.log(sub_item, media_data[sub_item]);
                if(media_data[sub_item].media_key === current_keys[item]) {
                    if(media_data[sub_item].type === 'video') {
                        const tweet_object_v1 = await twitterClient.get(`https://api.twitter.com/1.1/statuses/show.json?id=${tweet_id}&include_entities=true&tweet_mode=extended`);          
                        let bitrate = 0;
                        for (let j = 0; j < tweet_object_v1.extended_entities.media[0].video_info.variants.length; j++) {
                            if (tweet_object_v1.extended_entities.media[0].video_info.variants[j].bitrate) {
                                if (tweet_object_v1.extended_entities.media[0].video_info.variants[j].bitrate > bitrate) {
                                    bitrate = tweet_object_v1.extended_entities.media[0].video_info.variants[j].bitrate;
                                    hq_video_url = tweet_object_v1.extended_entities.media[0].video_info.variants[j].url;
                                }
                            }
                        }
                        // console.log(hq_video_url);
                    }else{
                        media_objects.push([current_keys[item], media_data[sub_item].type, media_data[sub_item].url]);
                    }
                }
            }
        }
        // console.log(media_objects);
    } catch (error) {
        console.log(error);
    }

    // Create dinamically embeds from amount of media keys
    array_embeds = [];
    for(const embed_item in media_objects) {
        array_embeds.push(
            new Discord.MessageEmbed()
                .setDescription(content_tweet)
                .setColor('#1da1f2')
                .setURL('https://www.google.com')
                .setImage(media_objects[embed_item][2]),
            );
    }

    // If there's no media, It will push an embed without image
    if(array_embeds.length === 0) {
        array_embeds.push(
            new Discord.MessageEmbed()
            .setDescription(content_tweet)
            .setColor('#1da1f2')
            .setURL('https://www.google.com')
            ,
        );
    }
    
    const message = await interaction.fetchReply();

    interaction.deleteReply();

    // Webhook 
    const channel = client.channels.cache.get(message.channel.id);
    function selection() {
        if(array_embeds.length === 1) {
            return [array_embeds[0]];
        }else if(array_embeds.length === 2) {
            return [array_embeds[0], array_embeds[1]];
        }else if(array_embeds.length === 3) {
            return [array_embeds[0], array_embeds[1], array_embeds[2]];
        }else if(array_embeds.length === 4) {
            return [array_embeds[0], array_embeds[1], array_embeds[2], array_embeds[3]];
        }
    }
    try {
		const webhooks = await channel.fetchWebhooks();
		const webhook = webhooks.first();
 
        if (webhooks.first() === undefined) {
            channel.createWebhook('Nadeshiko-Webhook', {
                avatar: 'https://i.imgur.com/AfFp7pu.png',
            }).then(webhook => 
                webhook.send({
                    content: content_tweet,
                    username: name_user,
                    avatarURL: url_avatar,
                }),
            ).catch(console.error);
        
        }else{
            await webhook.send({
                // content: content_tweet,
                username: name_user,
                avatarURL: url_avatar,
                embeds: selection(),
            });
            if (hq_video_url != 'none') {
                sendWebhook(channel, hq_video_url);
            }
        }
 
    }catch (error) {
		console.error('Error trying to send a message: ', error);
	}
}

async function sendWebhook(channel, text) {
    try {
        const webhooks = await channel.fetchWebhooks();
		const webhook = webhooks.first();
        await webhook.send({
            content: '`Video obtenido:`' + hider + text,
            username: name_user,
            avatarURL: url_avatar,
        });
    } catch (error) {
        console.log(error);
    }
}